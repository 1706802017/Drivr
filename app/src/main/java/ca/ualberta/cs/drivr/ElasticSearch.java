package ca.ualberta.cs.drivr;

import android.location.Location;
import android.net.ConnectivityManager;

import java.util.ArrayList;

/**
 * Created by colton on 2016-10-23.
 * Edited by tiegan on 2016-10-30.
 * This is the class that interacts with the elastic search database through RESTFUL commands
 * (so isn't it a controller? Or uses a controller?)
 */

/**
 * For location (by geo):
 * "geo_distance": {
 *    "distance": "50km",
 *    "location": [lat, lon] - gotten from given geo-distance
 * }
 *
 * For location (by search):
 * get lat/lon from something - Google? another function?
 * "geo_distance": {
 *     "distance": "50km"
 *     "location": [lat, lon]
 * }
 * (It's literally the same as above. You just need to do one extra step to see if it's a valid location)
 *
 * For user profile:
 * "username": (given username)
 * (usernames should be unique, should be fine)
 *
 * For requests:
 * "username": (given username)
 * (we're searching for rider/driver's requests, not requests near them, so identifier is just
 * their username)
 * (difference between this and user profile is just where we're getting the info from/what we're returning)
 *
 * Requests:
 * ID - id of request in ES
 * Rider - Name of user who made the request
 * Driver - Name of user who accepted request (initially NULL)
 * Status - status of the request (initially pending)
 * Source Location - Lat/Lon of location rider wants to be picked up from
 * Destination Location - Lat/Lon of location
 * Payment - Amount request will pay out (driver)/be paid (rider)
 * Approx. time - Amount of time request will take
 * Pick-up time - Time of pick-up (NULL if not specified - will just be given as "pick me
 * up right fucking now")
 *
 * User Profile:
 * Username
 * Profile image (ummmm, yeah, have fun with that)
 * Name
 * E-mail
 * Phone #
 * Address
 * Credit card info (stored, not gotten)
 *
 * Offline requests:
 * -Maybe store in something like JSON? (don't want to have to repeat making the request)
 * -Update it each time a call to ES is made (when connected) - basically caching it
 *
 * Offline/Online behaviour is not to be implemented right now (US 8), but will be worked upon
 *
 * Here's just my thinking of how to do this:
 * Use ElasticSearchController as the Controller (maybe change the name to better reflect)
 * Use ElasticSearch (this) as Model - store info gotten, send info to ES
 */

/**
 * Info dump: (Nov. 5 I think?)
 * Users:
 * -two methods:
 * --saveUser (save user info to ES) (required: all user info)
 * --loadUser (get user info from ES) (required: username)
 * -info:
 * --UserID (generated by ES)
 * --Username
 * --Phone Number
 * --E-mail
 * --Address
 * --Rating (set as null)
 *
 * Requests:
 * -four methods:
 * --loadRequests (loads all requests specified from ES)
 * ---loadRequestsByUsername (loads all requests for a user)
 * ---loadRequestsByLocation (loads all requests by given geolocation)
 * --loadRequest (loads specific request from ES) (requires ID)
 * --saveRequest (saves request to ES) (requires request info)
 * --updateRequest (updates stored request in ES) (requires ID)
 * -info:
 * --RequestID (generated by ES)
 * --RequestGiver (user who generated request)
 * --RequestTaker (user who accepts request)
 * --LatSource (source latitude of request)
 * --LongSource (source longitude of request)
 * --LatDest (destination latitude of request)
 * --LongDest (destination longitude of request)
 * --Price (amount request will require)
 * --EstTime (estimated time request will take)
 * --Pick-up time (null if not given)
 *
 * Other tidbits:
 * -Save all offline requests into its own array list (easier to save when you get connected again)
 * -Use array list for caching, update when there's been a change in the list
 */

public class ElasticSearch {
    private ArrayList<Request> offlineRequests;
    private ArrayList<Request> requestsMadeOffline;
    private ArrayList<Request> offlineUpdateRequest;
    private User user;
    //TODO: You wanna fix this, errr?
    private ConnectivityManager connectivityManager = new ConnectivityManager();

    public ArrayList<Request> searchRequestByGeolocation(android.location.Location geolocation){
        if(connectivityManager.getActiveNetworkInfo().isConnected()) {
            ElasticSearchController.SearchForLocationRequests searchRequest = new ElasticSearchController.SearchForLocationRequests();
            searchRequest.execute(geolocation);
            return searchRequest.get();
        } else {
            return null;
        }
    }

    /**
     *
     * @param searchTerm
     * @return
     */
    public ArrayList<Request> searchRequestByLocation(String searchTerm) {
        if(connectivityManager.getActiveNetworkInfo().isConnected()) {
            // Here you use the given search location, see if it's real.
            // If it is go onto the next section.
            // Else return null (indicating not found)
            Location geolocation = new Location("location");
            geolocation.setLatitude(0.0d);
            geolocation.setLatitude(0.0d);
            if(true) {
                ElasticSearchController.SearchForLocationRequests searchRequest = new ElasticSearchController.SearchForLocationRequests();
                searchRequest.execute(geolocation);
                return searchRequest.get();
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * Save shit.
     *
     * @param request
     */
    public void saveRequest(Request request){
        if(connectivityManager.getActiveNetworkInfo().isConnected()) {
            ElasticSearchController.AddRequest addRequest = new ElasticSearchController.AddRequest();
            addRequest.execute(request);
        } else {
            offlineUpdateRequest.add(request);
        }
    }

    /**
     * Update shit.
     *
     * @param request
     */
    public void updateRequest(Request request){
        if(connectivityManager.getActiveNetworkInfo().isConnected()) {
            ElasticSearchController.UpdateRequest updateRequest = new ElasticSearchController.UpdateRequest();
            updateRequest.execute(request);
        } else {
            offlineUpdateRequest.add(request);
        }
    }

    /**
     * Load requests the user is or has been involved in.
     *
     * @param username
     * @return Request
     */
    public ArrayList<Request> loadRequests(String username){
        if(connectivityManager.getActiveNetworkInfo().isConnected()) {
            ElasticSearchController.SearchForRequests requests = new ElasticSearchController.SearchForRequests();
            requests.execute(username);
            return requests.get();
        } else {
            return offlineRequests;
        }
    }

    /**
     * Saves the user in ElasticSearch if they are connected to the internet. Else it'll store
     * the data and wait to come back online.
     *
     * (since it's a pre-req when starting up 